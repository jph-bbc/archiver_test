# Функция аrchiver принимает текст в виде строки и возвращает его сжатую версию.
# Сжатие осуществляется путем подсчета повторяющихся символов и замены их числом, указывающим количество повторений.
def аrchiver(text: str) -> str:
    # функция проверяет, что входной аргумент является строкой. Если это не так,
    # то возвращается сообщение 'Входной текст должен быть строкой'
    try:
        int(text)
        return 'Входной текст должен быть строкой'
    except:
        # проверяется, если входной текст пуст, то возвращается сообщение 'Введена пустая строка'
        if not text:
            return 'Введена пустая строка'
        # Создается пустой список compressed_text, который будет содержать сжатую версию текста.
        compressed_text = []
        # Создается переменная Count, которая будет считать количество повторяющихся подряд символов
        count = 1
        # Итерируем по тексту с помощью цикла for, начиная со второго символа.
        for i in range(1, len(text)):
            # Если текущий символ цифра, добавляем предыдущий в конец списка.
            if text[i].isdigit():
                compressed_text.append(text[i - 1])
            else:
                # Если текущий символ равен предыдущему символу, увеличиваем счетчик count на 1.
                if text[i] == text[i - 1]:
                    count += 1
                else:
                    # Если текущий символ отличается от предыдущего, добавляем предыдущий символ в compressed_text.
                    compressed_text.append(text[i - 1])
                    # Если count больше 1, добавляем количество повторений в виде строки.
                    if count > 1:
                        compressed_text.append(
                            str(count))
                    # Сохраняем текущий символ как предыдущий и сбрасываем счетчик count в 1.
                    count = 1
        # После завершения цикла, добавляем последний символ в compressed_text
        compressed_text.append(text[-1])
        # Если count больше 1, добавляем количество повторений в виде строки.
        if count > 1:
            compressed_text.append(str(count))
        # Возвращаем сжатую версию текста, объединив все элементы списка compressed_text в одну строку с помощью
        # метода join.
        return ''.join(compressed_text)


# Функция unpacker принимает сжатый текст в виде строки и возвращает его распакованную версию.
# Распаковка осуществляется путем повторения символов в соответствии с указанным числом повторений.
def unpacker(text: str) -> str:
    # функция проверяет, что входной аргумент является строкой. Если это не так,  то возвращается сообщение 'Входной
    # текст должен быть строкой'
    try:
        int(text)
        return 'Входной текст должен быть строкой'
    except:
        # проверяется, если входной текст пуст, то возвращается сообщение 'Введена пустая строка'
        if not text:
            return 'Введена пустая строка'
        # Создается пустой список uncompressed_text, который будет содержать распакованную версию текста.
        uncompressed_text = []
        # Создается счетчик i для прохождения по всем символам строки
        i = 0
        # Если строка состоит из одного символа - возвращаем этот же один символ
        if len(text) == 1:
            uncompressed_text.append(text[i])
        else:
            # Итерируем по тексту с помощью цикла while, начиная с первого символа.
            while i < len(text) - 1:
                # Если после пробела стоит цифра, то выводим пробел, а не пробел, умноженный на цифру
                if text[i] == ' ' and text[i + 1].isdigit():
                    uncompressed_text.append(text[i])
                    # Индекс i увеличивается на 1
                    i += 1
                # Если следующий символ не является цифрой, то текущий символ добавляется в uncompressed_text
                elif text[i].isdigit() and text[i + 1].isdigit():
                    uncompressed_text.append(text[i])
                    # Индекс i увеличивается на 1
                    i += 1
                # Если следующий символ является цифрой
                elif text[i + 1].isdigit():
                    # текущий символ повторяется указанное количество раз и добавляется в uncompressed_text
                    uncompressed_text.append(text[i] * int(text[i + 1]))
                    # Индекс i увеличивается на 2
                    i += 2
                else:
                    # Если следующий символ не является цифрой, то текущий символ добавляется в uncompressed_text
                    uncompressed_text.append(text[i])
                    # Индекс i увеличивается на 1
                    i += 1
                    # Если i достигает последнего символа, то он также добавляется
                if i == len(text) - 1:
                    uncompressed_text.append(text[i])

        # Возвращается распакованная версия текста,
        # объединяя все элементы списка uncompressed_text в одну строку с помощью метода join.
        return ''.join(uncompressed_text)
